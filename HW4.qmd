---
title: "Homework Assignment #4"
subtitle: "Prioritizing Potential Aquaculture"
author: "Xue Yan"
date: 11/19/2024
execute: 
  eval: true
  warning: false
  message: false
format:
  html:
    toc: true
editor_options: 
  chunk_output_type: console
---

### 1. Library, function, and data preparation

```{r}
# Load libraries
library(here)
library(sf)
library(stars)
library(terra)
library(units)          # for droping units of the data (Bathymetry)
library(tmap)
library(tmaptools)      # for reading OpenStreetMap data
library(knitr)          # for generating table
library(dplyr)
library(tidyverse)
library(testthat)
```

```{r}
# Load data
#| code-fold: true

## West Coast EEZ
wc_region <- sf::st_read(here::here("data","wc_regions_clean.shp"), quiet = TRUE)

## Bathymetry
Bathymetry <- stars::read_stars(here::here("data", "depth.tif"), quiet = TRUE)
                                
## Sea Surface Temperature

### Read the path of all temperature files
files <- list.files(
  here("data"), pattern = "average*", 
  full.names = TRUE)

SST <- data.frame(file_name = files)

### Combine all temperature file into a raster stack and calculate average
SST_stack <- SST$file_name %>%
  lapply(read_stars) %>%      # Generate a list with stars files
  do.call(c, .)               # Generate the raster stack

### Calculate average temperature and save as a raster 
SST_ave <- st_apply(SST_stack, MARGIN = c("x", "y"), 
                    FUN = mean, na.rm = TRUE) %>%
           write_stars("SST_mean.tif")

### Convert average SST from Kelvin to Celsius
SST_aveC <- SST_ave - 273.15
```

```{r}
# Check if coordinate reference systems (CRS) of all data match
if ((st_crs(wc_region) == st_crs(Bathymetry)) &&
    (st_crs(wc_region) == st_crs(SST_aveC))) {
  print("all match!")
} else {
  print("not match")
}
```

```{r}
# Crop depth raster to match the extent of the SST raster
SST_extent <- st_bbox(SST_aveC)
Bathymetry_cropped <- st_crop(Bathymetry, SST_extent)

# Resample the depth data to match the resolution of the SST data 
# using the nearest neighbor approach
Bathymetry_resampled <- st_warp(Bathymetry_cropped, SST_aveC, method = "near")
```

```{r}
# Check that the depth and SST match in resolution, extent, and coordinate reference system

## Try to stack
stack_raster <- tryCatch({
  c(SST_aveC, Bathymetry_resampled)  # Try stacking the rasters
}, error = function(e) {
  NULL  # If stacking fails, return NULL
})

## Check if successfully stack
if (!is.null(stack_raster)) {
  print("all match!")
} else {
  print("not match")
}
```

### 2. Set workflow for selecting suitable environment conditions for Oyster

```{r}
#| code-fold: true
# Set workflow for selecting suitable environment conditions for oyster

oysters <- function(Species, SST, Depth){
  # Drop units of Baythemetry data
  Depth_drop <- drop_units(Depth)
  
  # Set suitable values to 1 and unsuitable values to 0
  # This process will generate "matrix" "array" data
  SST_suit <- ifelse(SST[[1]] >= 11 & SST[[1]] <= 30, 1, 0)
  Depth_suit <- ifelse(Depth_drop[[1]] >= -70 & Depth_drop[[1]] <= 0, 1, 0) 
  
  # Transform the "matrix" "array" data to "stars"
  SST_stars <- st_as_stars(SST_suit, dimensions = st_dimensions(SST))
  Depth_stars <- st_as_stars(Depth_suit, dimensions = st_dimensions(Depth))
  
  # Check if the new data match in resolution, extent, and CRS
  ## Try to stack
  stack_raster <- tryCatch({
    c(SST_stars, Depth_stars)
  }, error = function(e) {
    NULL # If stacking fails, return NULL
  })
  ## Check if successfully stack
  if (!is.null(stack_raster)) {
    print("all match!")
  } else {
    print("not match")
  }
  
  # Find suitable locations
  oyster_suit <- SST_stars * Depth_stars

  # Set unsuitable area as NA
  oyster_suit[oyster_suit == 0] <- NA
}

# Crop the extent of suitable area to Exclusive Economic Zones
cropped_oyster_suit <- stars::st_crop(oyster_suit, wc_region)
# Find the total suitable area within each EEZ



# Map the suitable area for oyster
## Download base map from OSM of the bounding box
background_data <- tmaptools::read_osm(sf::st_bbox(SST_extent))

## Keep raster data the same CRS to OSM
oyster_suit_sameCRS <- st_transform(oyster_suit, 
                                    crs = st_crs(background_data))

  ## Map
  tm_shape(background_data) + 
    tm_rgb() +
    tm_shape(oyster_suit_sameCRS) +
    tm_raster(palette = "red",
              title = "",
              labels = paste("Suitable area for", Species)) +
    tm_credits("© OpenStreetMap contributors",
              position=c("left", "bottom")) +
    tm_layout(legend.text.size = 0.85,
              legend.text.fontface = "bold",
              legend.title.size = 1,
              legend.title.fontface = "bold",
              legend.position = c("left","bottom")) +
  tm_scale_bar(position = c(0,0),
              breaks = c(0,5,10,15)) +
  tm_compass(position = c(0,0.8),
            size = 1.3)
  }
```

### 3. Set workflow for selecting suitable environment conditions for Dungeness Crab

```{r}
dungeness_crab <- function(Species, SST, Depth){
  # Drop units of Baythemetry data
  Depth_drop <- drop_units(Depth)
  
  # Set suitable values to 1 and unsuitable values to 0
  # This process will generate "matrix" "array" data
  SST_suit <- ifelse(SST[[1]] >= 3 & SST[[1]] <= 19, 1, 0)
  Depth_suit <- ifelse(Depth_drop[[1]] >= --360 & Depth_drop[[1]] <= 0, 1, 0) 
  
  # Transform the "matrix" "array" data to "stars"
  SST_stars <- st_as_stars(SST_suit, dimensions = st_dimensions(SST))
  Depth_stars <- st_as_stars(Depth_suit, dimensions = st_dimensions(Depth))
  
  # Check if the new data match in resolution, extent, and CRS
  ## Try to stack
  stack_raster <- tryCatch({
    c(SST_stars, Depth_stars)
  }, error = function(e) {
    NULL # If stacking fails, return NULL
  })
  ## Check if successfully stack
  if (!is.null(stack_raster)) {
    print("all match!")
  } else {
    print("not match")
  }
  

  # Find suitable locations
  crab_suit <- SST_stars * Depth_stars

  # Set unsuitable area as NA
  crab_suit[crab_suit == 0] <- NA

  # Map the suitable area for crab
  ## Download base map from OSM of the bounding box
  background_data <- tmaptools::read_osm(sf::st_bbox(SST_extent))

  ## Keep raster data the same CRS to OSM
  crab_suit_sameCRS <- st_transform(crab_suit, 
                                       crs = st_crs(background_data))

  ## Map
  tm_shape(background_data) + 
    tm_rgb() +
    tm_shape(crab_suit_sameCRS) +
    tm_raster(palette = "purple",
              title = "",
              labels = paste("Suitable area for", Species)) +
    tm_credits("© OpenStreetMap contributors",
              position=c("left", "bottom")) +
    tm_layout(legend.text.size = 0.85,
              legend.text.fontface = "bold",
              legend.title.size = 1,
              legend.title.fontface = "bold",
              legend.position = c("left","bottom")) +
  tm_scale_bar(position = c(0,0),
              breaks = c(0,5,10,15)) +
  tm_compass(position = c(0,0.8),
            size = 1.3)
}
```

### 4. Generate suitable area for Oyster and Dungeness Crab

```{r}
oysters_map <- oysters(Species = "Oyster", 
                   SST = SST_aveC,
                   Depth = Bathymetry_resampled)

dungeness_craba_map <- dungeness_crab(Species = "Dungeness Crab", 
                                 SST = SST_aveC,
                                 Depth = Bathymetry_resampled)

tmap_arrange(oysters_map, dungeness_craba_map, ncol = 2)
```

```{r}
## for test
  # Drop the units (m) of Bathymetry data
  Depth <- drop_units(Bathymetry_resampled)
  
  # Set suitable values to 1 and unsuitable values to 0
  # This process will generates a "matrix"/"array" objective
  SST_suit <- ifelse(SST_aveC[[1]] >= 11 & SST_aveC[[1]] <= 30, 1, 0)
  Depth_suit <- ifelse(Depth[[1]] >= -70 & Depth[[1]] <= 0, 1, 0) 
  
  # Transform the "matrix"/"array" objective to "stars" format
  SST_stars <- st_as_stars(SST_suit, dimensions = st_dimensions(SST_aveC))
  Depth_stars <- st_as_stars(Depth_suit, 
                             dimensions = st_dimensions(Depth))
  ## Try to stack
stack_raster <- tryCatch({
  c(SST_stars, Depth_stars)  # Try stacking the rasters
}, error = function(e) {
  NULL  # If stacking fails, return NULL
})

## Check if successfully stack 
if (!is.null(stack_raster)) {
  print("all match!")
} else {
  print("not match")
}
  
# Find suitable locations
oyster_suit <- SST_stars * Depth_stars

# Set unsuitable area as NA
oyster_suit[oyster_suit == 0] <- NA


# Transform data format from stars/sf to terra
# Keep same projection (EPSG:5070, Projection method: Albers Equal Area, unit:m)
oyster_suit_terra <- terra::rast(oyster_suit) %>%
                     terra::project("EPSG:5070")
wc_region_terra <- terra::vect(wc_region)%>%
                     terra::project("EPSG:5070")


# Find suitable area within the extent of Exclusive Economic Zones
oyster_suit_EEZ <- terra::mask(oyster_suit_terra, wc_region_terra)

# Rasterize Exclusive Economic Zones data
EEZ_rasterized <- terra::rasterize(wc_region_terra,
                                   oyster_suit_terra,
                                   field = "rgn_id") 

# Find suitable area within EEZ
## Generate a raster with area information
oyster_cell_size <- terra::cellSize(oyster_suit_EEZ)

## Find suitable area within each EEZ
suitable_area <- terra::zonal(oyster_cell_size, EEZ_rasterized, 
                              fun = "sum", 
                              na.rm = TRUE) 

## Transform the unit of the data and add the name of EEZ
suitable_area$area_km2 <- suitable_area$area / 1e6
suitable_area$EEZ_name <- c("Oregon", "Northern California",
                            "Central California", "Southern California",
                            "Washington")

## Generate a summary table


# Map the suitable area for oyster
## Download base map from OSM of the bounding box
background_data <- tmaptools::read_osm(sf::st_bbox(SST_extent))

## Keep raster data the same CRS to OSM
oyster_suit_sameCRS <- st_transform(oyster_suit, 
                                       crs = st_crs(background_data))

## Map
oyster_map <- tm_shape(background_data) + 
                tm_rgb() +
                tm_shape(oyster_suit_sameCRS) +
                tm_raster(palette = "red",
                          title = "",
                          labels = "Suitable area for Oyster" ) +
                tm_credits("© OpenStreetMap contributors",
                           position=c("left", "bottom")) +
                tm_layout(legend.text.size = 0.85,
                          legend.text.fontface = "bold",
                          legend.title.size = 1,
                          legend.title.fontface = "bold",
                          legend.position = c("left","bottom")) +
              tm_scale_bar(position = c(0,0),
                           breaks = c(0,5,10,15)) +
              tm_compass(position = c(0,0.8),
                         size = 1.3)
return(list(map = oyster_map, area_table = suitable_area))
```

```{r}
```

### Citation

| Reference | Citation | Link |
|------------------------|------------------------|------------------------|
| OpenStreetMap | OpenStreetMap contributors. (2015) Planet dump. \[November 21, 2024\]. Retrieved from [https://planet.openstree](https://planet.openstreetmap.org/) | <https://download.geofabrik.de/> |
| SeaLifeBase - Oyster/Dungeness Crab |  | <https://www.sealifebase.ca/search.php> |
|  |  |  |
